{"remainingRequest":"/Users/brianphan/jets/course-catalog-v2/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/brianphan/jets/course-catalog-v2/src/components/CustomDropdown.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/brianphan/jets/course-catalog-v2/src/components/CustomDropdown.vue","mtime":1609282060284},{"path":"/Users/brianphan/jets/course-catalog-v2/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/brianphan/jets/course-catalog-v2/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/brianphan/jets/course-catalog-v2/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/brianphan/jets/course-catalog-v2/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport SimpleSearch from '@/components/SimpleSearch';\nimport { HasProperty, clone } from '@/lib/utils';\nimport Vue from 'vue';\n\nexport default {\n\tname : 'custom-dropdown',\n\n\tprops : {\n\n\t\tdefault : String,\n\n\t\toptions : {\n\t\t\ttype : [Object, Array],\n\t\t},\n\n\t\tfield : {\n\t\t\ttype : Object\n\t\t},\n\n\t\terrors : {\n\t\t\ttype : [Object, String, Boolean],\n\t\t},\n\n\t\tlastTabIndex : {\n\t\t\ttype : Number,\n\t\t},\n\n\t\tvalue : {\n\t\t\ttype : [String, Number, Object, Array],\n\t\t},\n\n\t},\n\n\tdata : () => ( {\n\t\tlocalValue : '',\n\t\topen       : false,\n\n\t\tselected : {}, // + Used only when multiselect option is applied\n\n\t\tsearchQuery            : '',\n\t\tmultiSelectSearchState : 'closed',\n\n\t\tselectOptions : [],\n\t\toptionsState  : null,\n\n\t\tcloseTimeout : null,\n\t\tdisplayError : null,\n\t} ),\n\n\tcomputed : {\n\n\t\tdisplaySelected() {\n\t\t\tconst { selected, selectOptions, options } = this;\n\n\t\t\tif ( !selected || !Object.keys( selected ).length || !selectOptions || !selectOptions.length ) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst keys = Object.keys( selected ).filter( a => selected[a] );\n\n\t\t\tconst keyProp = options.keyProp || 'value';\n\n\t\t\treturn keys.map( ( key ) => {\n\t\t\t\tconst foundSelection  = selectOptions.find( a => a[keyProp] == key );\n\n\t\t\t\treturn foundSelection;\n\t\t\t} ).filter( a => a !== undefined );\n\t\t},\n\n\t\tdisplayText() {\n\t\t\tconst { selectOptions : options } = this;\n\n\t\t\tif ( this.optionsState === 'failed' ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( !options.length || this.optionsState === 'loading' ) {\n\t\t\t\treturn [this.options.loadingText || 'Loading...'];\n\t\t\t}\n\n\t\t\tconst placeholder = ( () => {\n\t\t\t\tconst { options : o } = this;\n\n\t\t\t\tif ( o.defaultText ) {\n\t\t\t\t\treturn o.defaultText;\n\t\t\t\t}\n\n\t\t\t\tif ( o.minimalLabel ) {\n\t\t\t\t\treturn o.minimalLabel;\n\t\t\t\t}\n\t\t\t} )();\n\n\t\t\tif ( !this.options.multiselect ) {\n\t\t\t\t// use soft equals here\n\t\t\t\tconst selected = options.find( a => a.value == this.localValue ) || {};\n\n\t\t\t\treturn [selected.text || placeholder];\n\t\t\t}\n\n\t\t\tconst keys     = Object.keys( this.selected );\n\t\t\tconst selected = keys.filter( a => this.selected[a] );\n\n\t\t\tconst { selectedText } = this.options;\n\n\t\t\tconst maxDisplayed = 2;\n\n\t\t\tif ( selectedText ) {\n\t\t\t\treturn selectedText( selected );\n\t\t\t}\n\n\t\t\tconst selectionLength = this.displaySelected.length;\n\n\t\t\tif ( selectionLength ) {\n\n\t\t\t\tif ( this.options.multiselectLabel === 'simple' ) {\n\t\t\t\t\treturn [`${selectionLength} selected`];\n\t\t\t\t}\n\n\t\t\t\treturn this.displaySelected.reduce( ( acc, value, index ) => {\n\n\t\t\t\t\t// if this is the first one and there's no other items\n\t\t\t\t\t// don't add a comma\n\t\t\t\t\tif ( index === 0 && selectionLength === 1 ) {\n\t\t\t\t\t\tacc.push( `${value.text}` );\n\t\t\t\t\t\treturn acc;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( index < maxDisplayed ) {\n\n\t\t\t\t\t\t// here we're checking to see if this is the last item in our array and\n\t\t\t\t\t\t// if it's the item that would be right before the \"and __ more\" item.\n\t\t\t\t\t\t// the reason why we're checking is so we can know if we should or\n\t\t\t\t\t\t// shouldn't add the comma at the end of the item.\n\t\t\t\t\t\tif ( ( index === maxDisplayed - 1 ) && ( index === selectionLength - 1 ) ) {\n\t\t\t\t\t\t\tacc.push( `${value.text}` );\n\t\t\t\t\t\t\treturn acc;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tacc.push( `${value.text},` );\n\t\t\t\t\t\treturn acc;\n\t\t\t\t\t}\n\n\t\t\t\t\t// if it's the last one we are able to display (due to maxDisplayed)\n\t\t\t\t\t// return how many are left that were selected\n\t\t\t\t\tif ( index === maxDisplayed ) {\n\t\t\t\t\t\tacc.push( `and ${selectionLength - maxDisplayed} more` );\n\t\t\t\t\t\treturn acc;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn acc;\n\n\t\t\t\t}, [] );\n\n\t\t\t}\n\n\t\t\treturn ['None selected'];\n\t\t},\n\n\t\thasErrors() {\n\t\t\treturn ( typeof this.displayError === 'string' && !!this.displayError );\n\t\t},\n\n\t\tselectedOption() {\n\n\t\t\tif ( Array.isArray( this.selectOptions ) ) {\n\t\t\t\treturn this.selectOptions.find( a => a.value === this.localValue );\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttext  : '',\n\t\t\t\tvalue : null,\n\t\t\t};\n\t\t},\n\n\t\tsearchPerfectMatch() {\n\t\t\tif ( this.localValue === '' || this.localValue === null ) {\n\t\t\t\treturn true; // ! this is temporary\n\t\t\t}\n\n\t\t\tif ( this.options.multiselect ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst { selectedOption : selected } = this;\n\n\t\t\treturn this.searchQuery === selected.text;\n\t\t},\n\n\t\tdisplayedOptions() {\n\t\t\tif ( this.options.searchable && this.searchQuery && !this.searchPerfectMatch ) {\n\t\t\t\treturn this.selectOptions.filter( a => a.text.toLowerCase().indexOf( this.searchQuery.toLowerCase() ) !== -1 );\n\t\t\t}\n\n\t\t\treturn this.selectOptions;\n\t\t},\n\n\t\tshowClearSelection() {\n\t\t\tif ( this.options.multiselect ) {\n\t\t\t\tconst keys = Object.keys( this.localValue );\n\n\t\t\t\treturn keys.find( a => this.localValue[a] ) !== undefined;\n\t\t\t}\n\n\t\t\treturn this.localValue !== '';\n\t\t},\n\n\t\tshowSearch() {\n\t\t\tif ( !this.options.multiselect ) {\n\t\t\t\treturn this.options.searchable;\n\t\t\t}\n\n\t\t\treturn ( this.options.searchable && this.multiSelectSearchState === 'open' );\n\t\t}\n\n\t},\n\n\tcreated() {\n\t\tif ( this.options.multiselect ) {\n\t\t\tif ( !Array.isArray( this.value ) ) {\n\t\t\t\tthis.selected = clone( this.value );\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tthis.selected = this.value.reduce( ( obj, item ) => {\n\t\t\t\t\tconst added = {};\n\t\t\t\t\tadded[item[this.options.keyProp]] = true;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...obj,\n\t\t\t\t\t\t...added,\n\t\t\t\t\t};\n\t\t\t\t}, {} );\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tthis.localValue = this.value;\n\t\t}\n\n\t\t// we must either display or\n\t\t// retrieve these options\n\t\tconst { options } = this.options;\n\n\t\t// this is a list. Nothing needs\n\t\t// to be done.\n\t\tif ( typeof options === 'object' || Array.isArray( options ) ) {\n\t\t\tthis.selectOptions = options;\n\t\t\tthis.setDefaultValue();\n\n\t\t\treturn;\n\t\t}\n\n\t\t// this is a function to either\n\t\t// generate programatically (e.g. 1-10)\n\t\t// or load from an external source.\n\t\tif ( typeof options === 'function' ) {\n\t\t\tthis.setOptions();\n\t\t}\n\t},\n\n\twatch : {\n\n\t\topen( open ) {\n\n\t\t\tthis.$nextTick( () => {\n\n\t\t\t\tif ( !open && this.$refs.optionsWrapper !== undefined ) {\n\t\t\t\t\tthis.$refs.optionsWrapper.scrollTop = 0;\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( open && ( this.options.multiselect && this.options.searchable ) ) {\n\t\t\t\tthis.multiSelectSearchState = 'open';\n\n\t\t\t\tthis.$nextTick( () => {\n\t\t\t\t\tthis.$refs.search.focus();\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tthis.multiSelectSearchState = 'closed';\n\t\t\t}\n\n\t\t},\n\n\t\t'value' : {\n\t\t\timmediate : true,\n\t\t\thandler( value ) {\n\t\t\t\tthis.displayError = null;\n\n\t\t\t\tif ( value !== this.localValue ) {\n\t\t\t\t\tthis.localValue = value;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tlocalValue( value ) {\n\t\t\tif ( value !== this.value ) {\n\t\t\t\tthis.$emit( 'input', value );\n\t\t\t}\n\t\t},\n\n\t\tsearchQuery() {\n\t\t\t// I added this so i could get the option.text\n\t\t\t// of the selected option if there is a better way lmk\n\t\t\t// I used this in the NewFiltersModal in the CustomDropdown - Tommy\n\t\t\tthis.$emit( 'text', this.searchQuery );\n\n\t\t\tif ( !this.options.searchable || this.options.multiselect ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\n\t\t\tif ( !this.searchPerfectMatch ) {\n\t\t\t\tthis.open = true;\n\t\t\t\tthis.localValue = '';\n\t\t\t}\n\t\t},\n\n\t\terrors( errors ) {\n\t\t\tif ( errors === false ) {\n\t\t\t\tthis.displayError = 'Required';\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.displayError = errors;\n\t\t},\n\n\t\t'selectedOption.text' : function ( text ) {\n\t\t\tif ( text == '' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( text !== this.searchQuery && this.options.searchable ) {\n\t\t\t\tthis.searchQuery = text;\n\t\t\t}\n\t\t},\n\n\t\t'selected' : {\n\t\t\tdeep : true,\n\t\t\thandler() {\n\t\t\t\tthis.setLocalValue();\n\t\t\t}\n\t\t},\n\n\t\tselectOptions() {\n\t\t\tthis.setLocalValue();\n\t\t}\n\n\t},\n\n\tmethods : {\n\n\t\tsetOptions() {\n\n\t\t\t// display a loading text in the dropdown\n\t\t\tconst loadingOption = {\n\t\t\t\ttext  : 'Loading Options...',\n\t\t\t\tvalue : null,\n\t\t\t};\n\n\t\t\tthis.optionsState  = 'loading';\n\t\t\tthis.selectOptions = [];\n\n\t\t\tconst { options } = this.options;\n\n\t\t\t// if a value is immediately\n\t\t\t// generated, this promise will immediately\n\t\t\t// resolve, otherwise it will resolve\n\t\t\t// when the promise fulfills\n\t\t\tPromise\n\t\t\t\t.resolve()\n\t\t\t\t.then( () => options() )\n\t\t\t\t.then( ( value ) => {\n\t\t\t\t\tthis.optionsState  = 'success';\n\t\t\t\t\tthis.selectOptions = value;\n\n\t\t\t\t\tthis.setDefaultValue();\n\t\t\t\t} )\n\t\t\t\t.catch( () => {\n\n\t\t\t\t\t// because this happens so quickly we want to let\n\t\t\t\t\t// the user know that we tried again upon their\n\t\t\t\t\t// request. We're going to do this by adding a\n\t\t\t\t\t// little magic and timing it out for visual effect\n\t\t\t\t\tsetTimeout( () => {\n\t\t\t\t\t\tthis.optionsState  = 'failed';\n\t\t\t\t\t\tthis.open          = false;\n\t\t\t\t\t\tthis.selectOptions = [];\n\t\t\t\t\t}, 1000 );\n\n\t\t\t\t} );\n\n\t\t},\n\n\t\tselect( option ) {\n\t\t\tif ( this.options.multiselect ) {\n\t\t\t\tconst value = ( () => {\n\t\t\t\t\tif ( option.value ) {\n\t\t\t\t\t\treturn option.value;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { keyProp } = this.options;\n\n\t\t\t\t\treturn option[keyProp];\n\t\t\t\t} )();\n\n\t\t\t\tVue.set( this.selected, value, !this.selected[value] );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tthis.localValue  = option.value;\n\t\t\t\tthis.searchQuery = option.text;\n\t\t\t}\n\n\t\t\tthis.open = false;\n\n\t\t\tif ( this.$refs.search ) {\n\t\t\t\tthis.$refs.search.blur();\n\t\t\t}\n\t\t},\n\n\t\tisSelected( option ) {\n\t\t\tconst value = ( () => {\n\t\t\t\tif ( option.value ) {\n\t\t\t\t\treturn option.value;\n\t\t\t\t}\n\n\t\t\t\treturn option[this.options.keyProp];\n\t\t\t} )();\n\n\t\t\treturn this.selected[value];\n\t\t},\n\n\t\ttoggleDropdown() {\n\t\t\tif ( this.searchQuery && !this.searchPerfectMatch ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.open = !this.open;\n\t\t},\n\n\t\tsetDefaultValue() {\n\t\t\tconst { defaultValue } = this.options;\n\n\t\t\tif ( !HasProperty( this.options, 'defaultValue' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( typeof defaultValue === 'function' ) {\n\t\t\t\t// start with promise.resolve because it will\n\t\t\t\t// support synchronous functions just fine but will\n\t\t\t\t// also support asynchronous functions\n\t\t\t\tPromise.resolve()\n\t\t\t\t\t.then( () => defaultValue() )\n\t\t\t\t\t.then( ( val ) => {\n\n\t\t\t\t\t\t// if the value we get is an object, set the value\n\t\t\t\t\t\t// and add the object to the beginning of the array\n\t\t\t\t\t\tif ( typeof val === 'object' ) {\n\t\t\t\t\t\t\tthis.localValue = val.value;\n\t\t\t\t\t\t\tthis.selectOptions.unshift( val );\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// otherwise just set the value\n\t\t\t\t\t\tthis.localValue = val;\n\t\t\t\t\t} )\n\t\t\t\t\t.then( () => {\n\t\t\t\t\t\t// check if the default value exists in the options.\n\t\t\t\t\t\t// if it doesn't, then we're just going to end up with\n\t\t\t\t\t\t// an empty dropdown looking at us which sucks.\n\t\t\t\t\t\tconst { localValue : val } = this;\n\n\t\t\t\t\t\t// find the selected option\n\t\t\t\t\t\tconst selectedOption = this.selectOptions.find( a => a.value === val );\n\t\t\t\t\t\tif ( selectedOption === undefined ) {\n\t\t\t\t\t\t\t// if it doesn't exist, then just set the localValue to an\n\t\t\t\t\t\t\t// empty string\n\t\t\t\t\t\t\tthis.localValue = '';\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.localValue = defaultValue;\n\t\t},\n\n\t\tsetCloseTimeout() {\n\t\t\tconst isSearchableMultiselect = ( this.options.multiselect && this.options.searchable );\n\n\t\t\tif ( this.searchQuery && !this.searchPerfectMatch && !isSearchableMultiselect ) {\n\t\t\t\t// don't autoclose a searched dropdown\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.closeTimeout = window.setTimeout( () => {\n\t\t\t\tthis.open = false;\n\n\t\t\t\tif ( isSearchableMultiselect ) {\n\t\t\t\t\tthis.searchQuery = '';\n\t\t\t\t}\n\t\t\t}, 200 );\n\t\t},\n\n\t\tclearCloseTimeout() {\n\t\t\tif ( this.closeTimeout ) {\n\t\t\t\twindow.clearTimeout( this.closeTimeout );\n\t\t\t}\n\t\t},\n\n\t\tclearSelection() {\n\t\t\tif ( !this.options.multiselect ) {\n\t\t\t\tthis.select( { value : \"\", text : \"\" } )\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst keys = Object.keys( this.selected );\n\t\t\tkeys.forEach( ( key ) => {\n\t\t\t\tthis.selected[key] = false;\n\t\t\t} );\n\t\t},\n\n\t\tsetLocalValue() {\n\t\t\tconst { selected, selectOptions, options } = this;\n\n\t\t\tif ( !selected || !Object.keys( selected ).length || !selectOptions || !selectOptions.length ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !options.keyProp ) {\n\t\t\t\tthis.localValue = selected;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst keys      = Object.keys( selected ).filter( a => selected[a] );\n\t\t\tthis.localValue = keys.map( ( key ) => {\n\t\t\t\tconst { keyProp }     = options;\n\t\t\t\tconst obj             = {};\n\n\t\t\t\tobj[keyProp] = key;\n\n\n\t\t\t\treturn obj;\n\t\t\t} );\n\t\t}\n\n\t},\n\n\tcomponents : {\n\t\tSimpleSearch,\n\t}\n};\n",{"version":3,"sources":["CustomDropdown.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6EA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA","file":"CustomDropdown.vue","sourceRoot":"src/components","sourcesContent":["<template lang=\"pug\">\n.dropdown.box(\n\t:class='{ open, optional : options.optional, \"has-value\" : localValue !== \"\" }' ref='dropdown'\n\t:tabindex='lastTabIndex'\n\t@mouseover='clearCloseTimeout'\n\t@mouseleave='setCloseTimeout'\n\t@keydown.enter='toggleDropdown'\n)\n\t.select-display.failed(v-if='optionsState === \"failed\"')\n\t\tp.reload.spacey.error(@click='setOptions') Reload Options\n\t\t\tspan.load-icon\n\t\t\t\tsvg(\n\t\t\t\t\txmlns='http://www.w3.org/2000/svg'\n\t\t\t\t\tversion='1.1'\n\t\t\t\t\twidth='512'\n\t\t\t\t\theight='512'\n\t\t\t\t\tviewBox='0 0 512 512'\n\t\t\t\t)\n\t\t\t\t\ttitle\n\t\t\t\t\tg#icomoon-ignore\n\t\t\t\t\tpath(\n\t\t\t\t\t\td='M444.84 83.16c-46.804-51.108-114.077-83.16-188.84-83.16-141.385 0-256 114.615-256 256h48c0-114.875 93.125-208 208-208 61.51 0 116.771 26.709 154.848 69.153l-74.848 74.847h176v-176l-67.16 67.16z'\n\t\t\t\t\t)\n\t\t\t\t\tpath(\n\t\t\t\t\t\td='M464 256c0 114.875-93.125 208-208 208-61.51 0-116.771-26.709-154.847-69.153l74.847-74.847h-176v176l67.16-67.16c46.804 51.108 114.077 83.16 188.84 83.16 141.385 0 256-114.615 256-256h-48z'\n\t\t\t\t\t)\n\n\t.select-display(v-else @click='toggleDropdown' :class='{ \"has-min-label\" : options.minimalLabel && ( localValue !== \"\" || searchQuery !== \"\" || hasErrors ) }')\n\t\t.icon-search(v-if='options.multiselect && options.searchable')\n\t\t.bubble(v-if='selectedOption && selectedOption.color' :style='{ backgroundColor : selectedOption.color }')\n\t\tp.minimal-label.highlight-text(v-if='options.minimalLabel') {{ options.minimalLabel }}\n\t\t\tspan(\n\t\t\t\tv-if='options.multiselect && options.searchable && open'\n\t\t\t\tv-for='text in displayText'\n\t\t\t)  {{ text }}\n\t\t\tspan.red.text-error(v-if='hasErrors') - {{ displayError }}\n\t\tinput.main-display(\n\t\t\tv-model='searchQuery'\n\t\t\t:placeholder='options.searchPlaceholder'\n\t\t\tv-if='showSearch'\n\t\t\tref='search'\n\t\t)\n\t\tp.main-display(v-else)\n\t\t\tspan(v-for='text in displayText')  {{ text }}\n\n\t.options-container(\n\t\tref='optionsWrapper'\n\t\t@mouseover='clearCloseTimeout'\n\t\t@mouseleave='setCloseTimeout'\n\t)\n\t\t.options-wrapper(v-show='open')\n\t\t\tp.spacey(v-if='!displayedOptions.length') No options to display\n\t\t\t.option(\n\t\t\t\tv-for='(option, index) in displayedOptions'\n\t\t\t\ttabindex='0'\n\t\t\t\t@click='select( option )'\n\t\t\t\t@keydown.enter.stop.prevent='select( option )'\n\t\t\t\t@keydown.escape='open = false'\n\t\t\t\t@blur='setCloseTimeout'\n\t\t\t\t@focus='clearCloseTimeout'\n\t\t\t)\n\t\t\t\t.bubble(v-if='option.color && !options.multiselect' :style='{ backgroundColor : option.color }')\n\t\t\t\t.checkbox(\n\t\t\t\t\tv-if='options.multiselect'\n\t\t\t\t\t:style='option.color ? { \"border-color\" : option.color } : {}'\n\t\t\t\t\t:class='{ checked : isSelected( option ) }'\n\t\t\t\t)\n\t\t\t\tp {{ option.text }}\n\t\t\t.option.clear(\n\t\t\t\tv-if='showClearSelection'\n\t\t\t\t@click='clearSelection()'\n\t\t\t)\n\t\t\t\tp Clear Selection\n\t\t\t\t.icon-close\n</template>\n\n<script>\nimport SimpleSearch from '@/components/SimpleSearch';\nimport { HasProperty, clone } from '@/lib/utils';\nimport Vue from 'vue';\n\nexport default {\n\tname : 'custom-dropdown',\n\n\tprops : {\n\n\t\tdefault : String,\n\n\t\toptions : {\n\t\t\ttype : [Object, Array],\n\t\t},\n\n\t\tfield : {\n\t\t\ttype : Object\n\t\t},\n\n\t\terrors : {\n\t\t\ttype : [Object, String, Boolean],\n\t\t},\n\n\t\tlastTabIndex : {\n\t\t\ttype : Number,\n\t\t},\n\n\t\tvalue : {\n\t\t\ttype : [String, Number, Object, Array],\n\t\t},\n\n\t},\n\n\tdata : () => ( {\n\t\tlocalValue : '',\n\t\topen       : false,\n\n\t\tselected : {}, // + Used only when multiselect option is applied\n\n\t\tsearchQuery            : '',\n\t\tmultiSelectSearchState : 'closed',\n\n\t\tselectOptions : [],\n\t\toptionsState  : null,\n\n\t\tcloseTimeout : null,\n\t\tdisplayError : null,\n\t} ),\n\n\tcomputed : {\n\n\t\tdisplaySelected() {\n\t\t\tconst { selected, selectOptions, options } = this;\n\n\t\t\tif ( !selected || !Object.keys( selected ).length || !selectOptions || !selectOptions.length ) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst keys = Object.keys( selected ).filter( a => selected[a] );\n\n\t\t\tconst keyProp = options.keyProp || 'value';\n\n\t\t\treturn keys.map( ( key ) => {\n\t\t\t\tconst foundSelection  = selectOptions.find( a => a[keyProp] == key );\n\n\t\t\t\treturn foundSelection;\n\t\t\t} ).filter( a => a !== undefined );\n\t\t},\n\n\t\tdisplayText() {\n\t\t\tconst { selectOptions : options } = this;\n\n\t\t\tif ( this.optionsState === 'failed' ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( !options.length || this.optionsState === 'loading' ) {\n\t\t\t\treturn [this.options.loadingText || 'Loading...'];\n\t\t\t}\n\n\t\t\tconst placeholder = ( () => {\n\t\t\t\tconst { options : o } = this;\n\n\t\t\t\tif ( o.defaultText ) {\n\t\t\t\t\treturn o.defaultText;\n\t\t\t\t}\n\n\t\t\t\tif ( o.minimalLabel ) {\n\t\t\t\t\treturn o.minimalLabel;\n\t\t\t\t}\n\t\t\t} )();\n\n\t\t\tif ( !this.options.multiselect ) {\n\t\t\t\t// use soft equals here\n\t\t\t\tconst selected = options.find( a => a.value == this.localValue ) || {};\n\n\t\t\t\treturn [selected.text || placeholder];\n\t\t\t}\n\n\t\t\tconst keys     = Object.keys( this.selected );\n\t\t\tconst selected = keys.filter( a => this.selected[a] );\n\n\t\t\tconst { selectedText } = this.options;\n\n\t\t\tconst maxDisplayed = 2;\n\n\t\t\tif ( selectedText ) {\n\t\t\t\treturn selectedText( selected );\n\t\t\t}\n\n\t\t\tconst selectionLength = this.displaySelected.length;\n\n\t\t\tif ( selectionLength ) {\n\n\t\t\t\tif ( this.options.multiselectLabel === 'simple' ) {\n\t\t\t\t\treturn [`${selectionLength} selected`];\n\t\t\t\t}\n\n\t\t\t\treturn this.displaySelected.reduce( ( acc, value, index ) => {\n\n\t\t\t\t\t// if this is the first one and there's no other items\n\t\t\t\t\t// don't add a comma\n\t\t\t\t\tif ( index === 0 && selectionLength === 1 ) {\n\t\t\t\t\t\tacc.push( `${value.text}` );\n\t\t\t\t\t\treturn acc;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( index < maxDisplayed ) {\n\n\t\t\t\t\t\t// here we're checking to see if this is the last item in our array and\n\t\t\t\t\t\t// if it's the item that would be right before the \"and __ more\" item.\n\t\t\t\t\t\t// the reason why we're checking is so we can know if we should or\n\t\t\t\t\t\t// shouldn't add the comma at the end of the item.\n\t\t\t\t\t\tif ( ( index === maxDisplayed - 1 ) && ( index === selectionLength - 1 ) ) {\n\t\t\t\t\t\t\tacc.push( `${value.text}` );\n\t\t\t\t\t\t\treturn acc;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tacc.push( `${value.text},` );\n\t\t\t\t\t\treturn acc;\n\t\t\t\t\t}\n\n\t\t\t\t\t// if it's the last one we are able to display (due to maxDisplayed)\n\t\t\t\t\t// return how many are left that were selected\n\t\t\t\t\tif ( index === maxDisplayed ) {\n\t\t\t\t\t\tacc.push( `and ${selectionLength - maxDisplayed} more` );\n\t\t\t\t\t\treturn acc;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn acc;\n\n\t\t\t\t}, [] );\n\n\t\t\t}\n\n\t\t\treturn ['None selected'];\n\t\t},\n\n\t\thasErrors() {\n\t\t\treturn ( typeof this.displayError === 'string' && !!this.displayError );\n\t\t},\n\n\t\tselectedOption() {\n\n\t\t\tif ( Array.isArray( this.selectOptions ) ) {\n\t\t\t\treturn this.selectOptions.find( a => a.value === this.localValue );\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttext  : '',\n\t\t\t\tvalue : null,\n\t\t\t};\n\t\t},\n\n\t\tsearchPerfectMatch() {\n\t\t\tif ( this.localValue === '' || this.localValue === null ) {\n\t\t\t\treturn true; // ! this is temporary\n\t\t\t}\n\n\t\t\tif ( this.options.multiselect ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst { selectedOption : selected } = this;\n\n\t\t\treturn this.searchQuery === selected.text;\n\t\t},\n\n\t\tdisplayedOptions() {\n\t\t\tif ( this.options.searchable && this.searchQuery && !this.searchPerfectMatch ) {\n\t\t\t\treturn this.selectOptions.filter( a => a.text.toLowerCase().indexOf( this.searchQuery.toLowerCase() ) !== -1 );\n\t\t\t}\n\n\t\t\treturn this.selectOptions;\n\t\t},\n\n\t\tshowClearSelection() {\n\t\t\tif ( this.options.multiselect ) {\n\t\t\t\tconst keys = Object.keys( this.localValue );\n\n\t\t\t\treturn keys.find( a => this.localValue[a] ) !== undefined;\n\t\t\t}\n\n\t\t\treturn this.localValue !== '';\n\t\t},\n\n\t\tshowSearch() {\n\t\t\tif ( !this.options.multiselect ) {\n\t\t\t\treturn this.options.searchable;\n\t\t\t}\n\n\t\t\treturn ( this.options.searchable && this.multiSelectSearchState === 'open' );\n\t\t}\n\n\t},\n\n\tcreated() {\n\t\tif ( this.options.multiselect ) {\n\t\t\tif ( !Array.isArray( this.value ) ) {\n\t\t\t\tthis.selected = clone( this.value );\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tthis.selected = this.value.reduce( ( obj, item ) => {\n\t\t\t\t\tconst added = {};\n\t\t\t\t\tadded[item[this.options.keyProp]] = true;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...obj,\n\t\t\t\t\t\t...added,\n\t\t\t\t\t};\n\t\t\t\t}, {} );\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tthis.localValue = this.value;\n\t\t}\n\n\t\t// we must either display or\n\t\t// retrieve these options\n\t\tconst { options } = this.options;\n\n\t\t// this is a list. Nothing needs\n\t\t// to be done.\n\t\tif ( typeof options === 'object' || Array.isArray( options ) ) {\n\t\t\tthis.selectOptions = options;\n\t\t\tthis.setDefaultValue();\n\n\t\t\treturn;\n\t\t}\n\n\t\t// this is a function to either\n\t\t// generate programatically (e.g. 1-10)\n\t\t// or load from an external source.\n\t\tif ( typeof options === 'function' ) {\n\t\t\tthis.setOptions();\n\t\t}\n\t},\n\n\twatch : {\n\n\t\topen( open ) {\n\n\t\t\tthis.$nextTick( () => {\n\n\t\t\t\tif ( !open && this.$refs.optionsWrapper !== undefined ) {\n\t\t\t\t\tthis.$refs.optionsWrapper.scrollTop = 0;\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( open && ( this.options.multiselect && this.options.searchable ) ) {\n\t\t\t\tthis.multiSelectSearchState = 'open';\n\n\t\t\t\tthis.$nextTick( () => {\n\t\t\t\t\tthis.$refs.search.focus();\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tthis.multiSelectSearchState = 'closed';\n\t\t\t}\n\n\t\t},\n\n\t\t'value' : {\n\t\t\timmediate : true,\n\t\t\thandler( value ) {\n\t\t\t\tthis.displayError = null;\n\n\t\t\t\tif ( value !== this.localValue ) {\n\t\t\t\t\tthis.localValue = value;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tlocalValue( value ) {\n\t\t\tif ( value !== this.value ) {\n\t\t\t\tthis.$emit( 'input', value );\n\t\t\t}\n\t\t},\n\n\t\tsearchQuery() {\n\t\t\t// I added this so i could get the option.text\n\t\t\t// of the selected option if there is a better way lmk\n\t\t\t// I used this in the NewFiltersModal in the CustomDropdown - Tommy\n\t\t\tthis.$emit( 'text', this.searchQuery );\n\n\t\t\tif ( !this.options.searchable || this.options.multiselect ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\n\t\t\tif ( !this.searchPerfectMatch ) {\n\t\t\t\tthis.open = true;\n\t\t\t\tthis.localValue = '';\n\t\t\t}\n\t\t},\n\n\t\terrors( errors ) {\n\t\t\tif ( errors === false ) {\n\t\t\t\tthis.displayError = 'Required';\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.displayError = errors;\n\t\t},\n\n\t\t'selectedOption.text' : function ( text ) {\n\t\t\tif ( text == '' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( text !== this.searchQuery && this.options.searchable ) {\n\t\t\t\tthis.searchQuery = text;\n\t\t\t}\n\t\t},\n\n\t\t'selected' : {\n\t\t\tdeep : true,\n\t\t\thandler() {\n\t\t\t\tthis.setLocalValue();\n\t\t\t}\n\t\t},\n\n\t\tselectOptions() {\n\t\t\tthis.setLocalValue();\n\t\t}\n\n\t},\n\n\tmethods : {\n\n\t\tsetOptions() {\n\n\t\t\t// display a loading text in the dropdown\n\t\t\tconst loadingOption = {\n\t\t\t\ttext  : 'Loading Options...',\n\t\t\t\tvalue : null,\n\t\t\t};\n\n\t\t\tthis.optionsState  = 'loading';\n\t\t\tthis.selectOptions = [];\n\n\t\t\tconst { options } = this.options;\n\n\t\t\t// if a value is immediately\n\t\t\t// generated, this promise will immediately\n\t\t\t// resolve, otherwise it will resolve\n\t\t\t// when the promise fulfills\n\t\t\tPromise\n\t\t\t\t.resolve()\n\t\t\t\t.then( () => options() )\n\t\t\t\t.then( ( value ) => {\n\t\t\t\t\tthis.optionsState  = 'success';\n\t\t\t\t\tthis.selectOptions = value;\n\n\t\t\t\t\tthis.setDefaultValue();\n\t\t\t\t} )\n\t\t\t\t.catch( () => {\n\n\t\t\t\t\t// because this happens so quickly we want to let\n\t\t\t\t\t// the user know that we tried again upon their\n\t\t\t\t\t// request. We're going to do this by adding a\n\t\t\t\t\t// little magic and timing it out for visual effect\n\t\t\t\t\tsetTimeout( () => {\n\t\t\t\t\t\tthis.optionsState  = 'failed';\n\t\t\t\t\t\tthis.open          = false;\n\t\t\t\t\t\tthis.selectOptions = [];\n\t\t\t\t\t}, 1000 );\n\n\t\t\t\t} );\n\n\t\t},\n\n\t\tselect( option ) {\n\t\t\tif ( this.options.multiselect ) {\n\t\t\t\tconst value = ( () => {\n\t\t\t\t\tif ( option.value ) {\n\t\t\t\t\t\treturn option.value;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { keyProp } = this.options;\n\n\t\t\t\t\treturn option[keyProp];\n\t\t\t\t} )();\n\n\t\t\t\tVue.set( this.selected, value, !this.selected[value] );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tthis.localValue  = option.value;\n\t\t\t\tthis.searchQuery = option.text;\n\t\t\t}\n\n\t\t\tthis.open = false;\n\n\t\t\tif ( this.$refs.search ) {\n\t\t\t\tthis.$refs.search.blur();\n\t\t\t}\n\t\t},\n\n\t\tisSelected( option ) {\n\t\t\tconst value = ( () => {\n\t\t\t\tif ( option.value ) {\n\t\t\t\t\treturn option.value;\n\t\t\t\t}\n\n\t\t\t\treturn option[this.options.keyProp];\n\t\t\t} )();\n\n\t\t\treturn this.selected[value];\n\t\t},\n\n\t\ttoggleDropdown() {\n\t\t\tif ( this.searchQuery && !this.searchPerfectMatch ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.open = !this.open;\n\t\t},\n\n\t\tsetDefaultValue() {\n\t\t\tconst { defaultValue } = this.options;\n\n\t\t\tif ( !HasProperty( this.options, 'defaultValue' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( typeof defaultValue === 'function' ) {\n\t\t\t\t// start with promise.resolve because it will\n\t\t\t\t// support synchronous functions just fine but will\n\t\t\t\t// also support asynchronous functions\n\t\t\t\tPromise.resolve()\n\t\t\t\t\t.then( () => defaultValue() )\n\t\t\t\t\t.then( ( val ) => {\n\n\t\t\t\t\t\t// if the value we get is an object, set the value\n\t\t\t\t\t\t// and add the object to the beginning of the array\n\t\t\t\t\t\tif ( typeof val === 'object' ) {\n\t\t\t\t\t\t\tthis.localValue = val.value;\n\t\t\t\t\t\t\tthis.selectOptions.unshift( val );\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// otherwise just set the value\n\t\t\t\t\t\tthis.localValue = val;\n\t\t\t\t\t} )\n\t\t\t\t\t.then( () => {\n\t\t\t\t\t\t// check if the default value exists in the options.\n\t\t\t\t\t\t// if it doesn't, then we're just going to end up with\n\t\t\t\t\t\t// an empty dropdown looking at us which sucks.\n\t\t\t\t\t\tconst { localValue : val } = this;\n\n\t\t\t\t\t\t// find the selected option\n\t\t\t\t\t\tconst selectedOption = this.selectOptions.find( a => a.value === val );\n\t\t\t\t\t\tif ( selectedOption === undefined ) {\n\t\t\t\t\t\t\t// if it doesn't exist, then just set the localValue to an\n\t\t\t\t\t\t\t// empty string\n\t\t\t\t\t\t\tthis.localValue = '';\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.localValue = defaultValue;\n\t\t},\n\n\t\tsetCloseTimeout() {\n\t\t\tconst isSearchableMultiselect = ( this.options.multiselect && this.options.searchable );\n\n\t\t\tif ( this.searchQuery && !this.searchPerfectMatch && !isSearchableMultiselect ) {\n\t\t\t\t// don't autoclose a searched dropdown\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.closeTimeout = window.setTimeout( () => {\n\t\t\t\tthis.open = false;\n\n\t\t\t\tif ( isSearchableMultiselect ) {\n\t\t\t\t\tthis.searchQuery = '';\n\t\t\t\t}\n\t\t\t}, 200 );\n\t\t},\n\n\t\tclearCloseTimeout() {\n\t\t\tif ( this.closeTimeout ) {\n\t\t\t\twindow.clearTimeout( this.closeTimeout );\n\t\t\t}\n\t\t},\n\n\t\tclearSelection() {\n\t\t\tif ( !this.options.multiselect ) {\n\t\t\t\tthis.select( { value : \"\", text : \"\" } )\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst keys = Object.keys( this.selected );\n\t\t\tkeys.forEach( ( key ) => {\n\t\t\t\tthis.selected[key] = false;\n\t\t\t} );\n\t\t},\n\n\t\tsetLocalValue() {\n\t\t\tconst { selected, selectOptions, options } = this;\n\n\t\t\tif ( !selected || !Object.keys( selected ).length || !selectOptions || !selectOptions.length ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !options.keyProp ) {\n\t\t\t\tthis.localValue = selected;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst keys      = Object.keys( selected ).filter( a => selected[a] );\n\t\t\tthis.localValue = keys.map( ( key ) => {\n\t\t\t\tconst { keyProp }     = options;\n\t\t\t\tconst obj             = {};\n\n\t\t\t\tobj[keyProp] = key;\n\n\n\t\t\t\treturn obj;\n\t\t\t} );\n\t\t}\n\n\t},\n\n\tcomponents : {\n\t\tSimpleSearch,\n\t}\n};\n</script>\n\n<style lang=\"scss\">\n@import '@/assets/variables.scss';\n\n.dropdown {\n\twidth: 200px;\n\tposition: relative;\n\tcursor: pointer;\n\n\t&::before {\n\t\ttop: 50% !important;\n\t\ttransform: translateY( -50% );\n\t}\n\n\t&:not(.open) {\n\t\tborder-bottom-left-radius: 15px;\n\t\tborder-bottom-right-radius: 15px;\n\n\t\t.options-container {\n\t\t\tmax-height: 0;\n\t\t\toverflow: hidden;\n\t\t\tpadding: 0;\n\t\t\tborder-color: transparent;\n\t\t\tbackground-color: transparent;\n\t\t\tz-index: -1;\n\n\t\t\t.options-wrapper {\n\n\t\t\t\t&::before {\n\t\t\t\t\theight: 0;\n\t\t\t\t\twidth: 0;\n\t\t\t\t}\n\n\t\t\t\t.option {\n\t\t\t\t\topacity: 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t.select-display {\n\n\t\t\t&::before {\n\t\t\t\ttransform: translate(0px, -50%) rotate(-45deg);\n\t\t\t}\n\n\t\t\t&::after {\n\t\t\t\ttransform: translate(5px, -50%) rotate(45deg);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.open {\n\t\tborder-bottom-left-radius: 0px!important;\n\t\tborder-bottom-right-radius: 0px!important;\n\t\tbox-shadow: none!important;\n\t\tz-index: 10;\n\n\t\t.select-display {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t.options-container {\n\n\t\t\t.options-wrapper {\n\n\t\t\t\t.option {\n\t\t\t\t\topacity: 1;\n\t\t\t\t\ttransform: translate3d(0,0,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t&.optional:not(.has-value):not(.open) {\n\t\tbox-shadow: none;\n\t\tborder: 2px dashed $secondary;\n\n\t\t.select-display {\n\t\t\tpadding: 13px;\n\t\t}\n\t}\n\n\t.select-display {\n\t\tpadding: 15px;\n\t\twidth: 100%;\n\t\tposition: relative;\n    z-index: 2;\n    background: white;\n\t\tborder-radius: 15px;\n\t\tposition: relative;\n\t\toverflow: hidden;\n\t\theight: 100%;\n\t\tdisplay: flex;\n\t\talign-items: center;\n\n\t\t.icon-search {\n\t\t\tmargin-right: 15px;\n\t\t\tcolor: $secondary;\n\n\t\t\t~ p.minimal-label {\n\t\t\t\tleft: 48px;\n\t\t\t}\n\t\t}\n\n\t\t&.failed {\n\n\t\t\t&::before, &::after {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\n\t\t\tp {\n\n\t\t\t\t&.error {\n\t\t\t\t\tcolor: $cancel;\n\t\t\t\t\tposition: relative;\n\t\t\t\t\twidth: 100%;\n\n\t\t\t\t\t.load-icon {\n\t\t\t\t\t\tfont-weight: 600;\n\t\t\t\t\t\tposition: absolute;\n\t\t\t\t\t\tright: 5px;\n\t\t\t\t\t\ttop: 50%;\n\t\t\t\t\t\ttransform: translateY(-50%);\n\t\t\t\t\t\tcolor: inherit;\n\n\t\t\t\t\t\tsvg {\n\t\t\t\t\t\t\theight: 16px;\n\t\t\t\t\t\t\twidth: 16px;\n\t\t\t\t\t\t\tfill: $cancel;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t.bubble {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 0;\n\t\t\theight: 20px;\n\t\t\twidth: 15px;\n\t\t\tborder-radius: 6px;\n\t\t\ttransform: translate(-50%,-50%);\n\t\t}\n\n\t\tinput {\n\t\t\twidth: 100%;\n\t\t\tcolor: $primary;\n\t\t}\n\n\t\t&.has-min-label {\n\n\t\t\tp.minimal-label {\n\t\t\t\topacity: 1;\n\t\t\t\ttransform: translate3d(0,-7px,0);\n\t\t\t}\n\n\t\t\t.main-display {\n\t\t\t\ttransform: translate3d(0,7px,0);\n\t\t\t}\n\t\t}\n\n\t\t&::before, &::after {\n\t\t\tcontent: ' ';\n\t\t\theight: 9px;\n\t\t\twidth: 2px;\n\t\t\tbackground: $primary;\n\t\t\tborder-radius: 12px;\n\t\t\tright: 30px;\n\t\t\tposition: absolute;\n\t\t\ttransition: .2s ease-in-out;\n\t\t\ttop: 50%;\n\t\t\ttransform: translate3d( 0, -50%, 0 );\n\t\t\tz-index: 2;\n\t\t}\n\n\t\t&::before {\n\t\t\ttransform: translate3d(0px, -50%, 0) rotate(45deg);\n\t\t}\n\n\t\t&::after {\n\t\t\ttransform: translate3d(5px, -50%, 0) rotate(-45deg);\n\t\t}\n\n\t\t.main-display {\n\t\t\ttransition: transform 0.2s ease;\n\n\t\t\tp:first-of-type {\n\t\t\t\tposition: relative;\n\t\t\t\ttop: 5px;\n\t\t\t\tpadding-bottom: 10px; // this is to offset the top positioning\n\t\t\t}\n\n\t\t\tp {\n\t\t\t\tpadding-bottom: 5px;\n\t\t\t}\n\t\t}\n\n\t\tp {\n\t\t\tcolor: $primary;\n\t\t\tfont-weight: 500;\n\t\t\toverflow: hidden;\n\t\t\tmargin: 0;\n\t\t\tfont-size: 16px;\n\n\t\t\t&.minimal-label {\n\t\t\t\tcolor: $primary;\n\t\t\t\tfont-size: 12px;\n\t\t\t\topacity: 0;\n\t\t\t\ttransform: translate3d(0,0,0);\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: 15px;\n\t\t\t\ttop: 15px;\n\t\t\t\ttransition: opacity 0.2s ease, transform 0.2s ease;\n\t\t\t}\n\t\t}\n\t}\n\n\t.options-container {\n\t\tpadding-top: 58px;\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tbackground: white;\n\t\tborder-radius: 15px;\n\t\tz-index: 1;\n\t\twidth: 100%;\n\t\tbox-shadow: $floatingObject;\n\t\toverflow: hidden;\n\n\t\t&::before {\n\t\t\tcontent: '';\n\t\t\tposition: absolute;\n\t\t\ttop: 55px;\n\t\t\tleft: 0;\n\t\t\twidth: 100%;\n\t\t\tz-index: -1;\n\t\t\theight: 50px;\n\t\t\tbackground: $gradientOne;\n\t\t}\n\n\t\t.options-wrapper {\n\t\t\toverflow: auto;\n\t\t\tpadding: 12px 0;\n\t\t\tmax-height: 200px;\n\t\t\tposition: relative;\n\n\t\t\t&::-webkit-scrollbar {\n\t\t\t\twidth: 0;\n\t\t\t}\n\n\t\t\tp.spacey {\n\t\t\t\ttext-align: center;\n\t\t\t}\n\n\t\t\t.option {\n\t\t\t\tpadding: 3px 15px;\n\t\t\t\twidth: 100%;\n\t\t\t\topacity: 0.75;\n\t\t\t\ttransform: translate3d(-10px, 0, 0);\n\t\t\t\topacity: 0;\n\t\t\t\ttransition: transform 0.15s ease, opacity 0.15s ease;\n\t\t\t\tdisplay: flex;\n\t\t\t\talign-items: center;\n\n\t\t\t\t&.clear {\n\t\t\t\t\topacity: 0.5;\n\t\t\t\t\tdisplay: flex;\n\t\t\t\t\talign-items: center;\n\t\t\t\t\tjustify-content: space-between;\n\n\t\t\t\t\t.icon-close {\n\t\t\t\t\t\theight: 10px;\n\t\t\t\t\t\twidth: 10px;\n\t\t\t\t\t\tmargin-right: 5px;\n\n\t\t\t\t\t\t&::before,\n\t\t\t\t\t\t&::after {\n\t\t\t\t\t\t\theight: 10px;\n\t\t\t\t\t\t\twidth: 2px;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tp {\n\t\t\t\t\t\tcolor: $cancel;\n\t\t\t\t\t\tfont-size: 12px;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t&:nth-child(2) {\n\t\t\t\t\ttransition-delay: 0.03s;\n\t\t\t\t}\n\n\t\t\t\t&:nth-child(3) {\n\t\t\t\t\ttransition-delay: 0.06s;\n\t\t\t\t}\n\n\t\t\t\t&:nth-child(4) {\n\t\t\t\t\ttransition-delay: 0.1s;\n\t\t\t\t}\n\n\t\t\t\t&:nth-child(5) {\n\t\t\t\t\ttransition-delay: 0.15s;\n\t\t\t\t}\n\n\t\t\t\t&:nth-child(6) {\n\t\t\t\t\ttransition-delay: 0.21s;\n\t\t\t\t}\n\n\t\t\t\t&:nth-child(7) {\n\t\t\t\t\ttransition-delay: 0.28s;\n\t\t\t\t}\n\n\t\t\t\t&:hover {\n\t\t\t\t\topacity: 1;\n\t\t\t\t}\n\n\t\t\t\t.checkbox {\n\t\t\t\t\theight: 18px;\n\t\t\t\t\twidth: 18px;\n\t\t\t\t\tmin-width: 18px;\n\t\t\t\t\tborder-radius: 3px;\n\t\t\t\t\tmargin-right: 10px;\n\t\t\t\t\tborder: 2px solid $lightGrey;\n\t\t\t\t\tposition: relative;\n\n\t\t\t\t\t&.checked {\n\t\t\t\t\t\tborder-color: $primary;\n\t\t\t\t\t\tbackground: lighten($primary, 30);\n\n\t\t\t\t\t\t&::after {\n\t\t\t\t\t\t\tcontent: ' ';\n\t\t\t\t\t\t\theight: 4px;\n\t\t\t\t\t\t\twidth: 8px;\n\t\t\t\t\t\t\tborder: 3px solid $primary;\n\t\t\t\t\t\t\tborder-top: 0;\n\t\t\t\t\t\t\tborder-right: 0;\n\t\t\t\t\t\t\tposition: absolute;\n\t\t\t\t\t\t\ttop: 35%;\n\t\t\t\t\t\t\tleft: 50%;\n\t\t\t\t\t\t\ttransform: translate(-50%,-50%) rotate(-45deg);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t+ p {\n\t\t\t\t\t\t\tcolor: $primary;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t.bubble {\n\t\t\t\t\tposition: relative;\n\t\t\t\t\theight: 10px;\n\t\t\t\t\twidth: 10px;\n\t\t\t\t\tborder-radius: 3px;\n\t\t\t\t\tmargin-right: 5px;\n\t\t\t\t\tflex-shrink: 0;\n\t\t\t\t}\n\n\t\t\t\tp {\n\t\t\t\t\ttext-align: left;\n\t\t\t\t\tmargin: 0 ;\n\t\t\t\t\tfont-weight: 500;\n\t\t\t\t\tfont-size: 14px;\n\t\t\t\t\tcolor: $primary;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n</style>\n"]}]}